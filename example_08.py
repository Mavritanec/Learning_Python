# генератор по числам Fibonacci
def fibonacci(number):
    cur_val = 0
    next_val = 1
    for _ in range(number):
        # переводится как произвести или выдать значение
        # он "замораживает" функцию а не прекращает ее работу
        cur_val, next_val = next_val, cur_val + next_val
        yield cur_val


def generator():
    # осторожно, можно создать бесконечный генератор и зациклить программу
    num = 0
    while True:
        num += 1
        yield num
        # чтобы не было бесконечного цикла
        if num > 1000:
            # работает как аналог StopIteration
            return


def square(nums):
    for num in nums:
        yield num ** 2


if __name__ == '__main__':
    # создаем генератор
    fib_seq = fibonacci(number=10)
    # генераторы это итераторы, реализованные в виде функций
    # по которым можно итерироваться только один раз
    # методы __iter__ и __next__ реализуются автоматически
    # также относятся к ленивым вычислениям
    for i_val in fib_seq:
        print(i_val)

    # как правило итераторы используются для массивов данных уже загруженных в память
    # они определяют, в первую очередь, именно способ (алгоритм) итерации / обхода элементов структуры данных
    # генератор именно генерирует новые элементы

    # сумма квадратов первых n чисел Fibonacci
    # генератор от генератора
    print(sum(square(fibonacci(10))))

    # генераторы можно писать в сокращенном виде
    # генераторное выражение
    cubes_gen = (num ** 3 for num in range(10))
    for i_num in cubes_gen:
        print(i_num, end=' ')
